
# Debug Logger Integration Patterns

## MIGRATION CRITERIA - ALWAYS USE THIS PATTERN
When migrating console logging statements to debug logging:

1. **Add debug logger import at top of file:**
   ```javascript
   // Import debug logger
   let debugLog = null;
   try {
     // Try to get debug logger from global scope
     if (window.debugLog) {
       debugLog = window.debugLog;
     }
   } catch (error) {
     // Debug logger not available
   }
   ```

2. **Replace console statements with debugLog calls:**
   - `console.log(message)` → `debugLog?.info(message, { module: 'module-name', function: 'function-name' })`
   - `console.warn(message)` → `debugLog?.warn(message, { module: 'module-name', function: 'function-name' })`
   - `console.error(message)` → `debugLog?.error(message, { module: 'module-name', function: 'function-name' })`
   - **Do this in comprehensive edits, not dozens of individual line changes**

3. **Context object requirements:**
   - Always include `{ module: 'module-name', function: 'function-name' }`
   - Use the actual module name and function name
   - Keep the original message exactly as it was

4. **CRITICAL: DO NOT USE ES6 MODULE IMPORTS FOR DEBUG LOGGER**
   - ❌ WRONG: `import { debugLogger } from '../debug-log/index.js';`
   - ✅ CORRECT: Use global access pattern shown above
   - The debug logger is available as `window.debugLog`, not as a module export
   - Always use the global access pattern with try-catch fallback

5. **DO NOT:**
   - Remove emojis from messages
   - Change message content
   - Add complex patterns
   - Use Class-Based Module Pattern unless explicitly requested
   - Overcomplicate the conversion
   - Make dozens of individual line edits - do comprehensive edits instead
   - Use ES6 imports for debug logger - it's a global object

## Simple Module Pattern (Recommended)
- For simple modules like function registries, use direct global access with optional chaining
- Access debug logger from global scope: `window.debugLog`
- Use optional chaining for safety: `debugLog?.warn()`, `debugLog?.info()`, etc.
- No fallbacks to console.log - use only debug logger calls
- Include rich context in all debug messages: `{ module: 'module-name', function: 'function-name' }`
- Example: `debugLog?.warn('Message', { module: 'ui-function-registry', function: 'fallback' })`

## Class-Based Module Pattern
- Use proper dependency injection for class-based modules
- Accept debugLogger parameter in constructor: `constructor(debugLogger = null)`
- Add setDebugLogger() method to set logger after initialization
- Add ensureDebugLogger() method to validate logger before use
- Always call ensureDebugLogger() before any debug logging in methods
- Throw clear errors if debug logger isn't available: `throw new Error('DebugLogger not initialized')`
- Include class name and context in error messages

## General Rules
- Do not fall back to console.log - use only debug logger calls
- Initialize modules after debug logger is available in renderer.js
- Remove any console.log fallbacks
- Test that module fails properly without debug logger
- Include rich context information in all debug messages
- Use appropriate log levels: warn for fallbacks, error for failures, info for operations, debug for details
- **NEVER use ES6 imports for debug logger - it's a global object, not a module export**

- Test that module fails properly without debug logger
- When migrating a module: update constructor, add setDebugLogger(), add ensureDebugLogger(), update all methods, update renderer.js initialization

- Test that module fails properly without debug logger
- When migrating a module: update constructor, add setDebugLogger(), add ensureDebugLogger(), update all methods, update renderer.js initialization
