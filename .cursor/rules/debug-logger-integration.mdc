---
alwaysApply: true
---

# Debug Logger Integration Patterns

## Simple Module Pattern (Recommended)
- For simple modules like function registries, use direct global access with optional chaining
- Access debug logger from global scope: `window.debugLog`
- Use optional chaining for safety: `debugLog?.warn()`, `debugLog?.info()`, etc.
- No fallbacks to console.log - use only debug logger calls
- Include rich context in all debug messages: `{ module: 'module-name', function: 'function-name' }`
- Example: `debugLog?.warn('Message', { module: 'ui-function-registry', function: 'fallback' })`

## Class-Based Module Pattern
- Use proper dependency injection for class-based modules
- Accept debugLogger parameter in constructor: `constructor(debugLogger = null)`
- Add setDebugLogger() method to set logger after initialization
- Add ensureDebugLogger() method to validate logger before use
- Always call ensureDebugLogger() before any debug logging in methods
- Throw clear errors if debug logger isn't available: `throw new Error('DebugLogger not initialized')`
- Include class name and context in error messages

## General Rules
- Do not fall back to console.log - use only debug logger calls
- Initialize modules after debug logger is available in renderer.js
- Remove any console.log fallbacks
- Test that module fails properly without debug logger
- Include rich context information in all debug messages
- Use appropriate log levels: warn for fallbacks, error for failures, info for operations, debug for details

- Test that module fails properly without debug logger
- When migrating a module: update constructor, add setDebugLogger(), add ensureDebugLogger(), update all methods, update renderer.js initialization
# Debug Logger Integration Patterns

## Simple Module Pattern (Recommended)
- For simple modules like function registries, use direct global access with optional chaining
- Access debug logger from global scope: `window.debugLog`
- Use optional chaining for safety: `debugLog?.warn()`, `debugLog?.info()`, etc.
- No fallbacks to console.log - use only debug logger calls
- Include rich context in all debug messages: `{ module: 'module-name', function: 'function-name' }`
- Example: `debugLog?.warn('Message', { module: 'ui-function-registry', function: 'fallback' })`

## Class-Based Module Pattern
- Use proper dependency injection for class-based modules
- Accept debugLogger parameter in constructor: `constructor(debugLogger = null)`
- Add setDebugLogger() method to set logger after initialization
- Add ensureDebugLogger() method to validate logger before use
- Always call ensureDebugLogger() before any debug logging in methods
- Throw clear errors if debug logger isn't available: `throw new Error('DebugLogger not initialized')`
- Include class name and context in error messages

## General Rules
- Do not fall back to console.log - use only debug logger calls
- Initialize modules after debug logger is available in renderer.js
- Remove any console.log fallbacks
- Test that module fails properly without debug logger
- Include rich context information in all debug messages
- Use appropriate log levels: warn for fallbacks, error for failures, info for operations, debug for details

- Test that module fails properly without debug logger
- When migrating a module: update constructor, add setDebugLogger(), add ensureDebugLogger(), update all methods, update renderer.js initialization
